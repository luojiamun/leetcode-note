### 思路

- 拿到题的直觉解法
    - 完全没思路，只能从答案来理解解题过程。
    - DP太差，需加强。

`Nothing`

- 从最简单的情形开始逐个推导dp公式
这部分就是类似于climb stairs的逻辑。
每个p都是确定走到当前位置的概率。因为最长步幅有W，因此一直从当前位置往前倒数的W个位置，都可以一步跨到当前位置，属于同等情况，需要做加法。
```
p0: 1
p1: p0 * 1/w
p2: p1 * 1/w + p0 * 1/w 
p3: p2 * 1/w + p1 * 1/w + p0 * 1/w
```
- 既然如此，我们其实可以求出来任意i位置的概率，就是上面公式的累加即可。
- 需要注意的一点是，我们要用到固定滑动窗口，来控制步幅，不在窗口范围的，即不在一步可跨越的范围，就不应该加起来，而应该去掉。
- 所以整个题目的结构，是以滑动窗口为模版的，类似于固定窗口左边缩进。每次都将当前位置的dp加入，一旦发现当前超过了步幅范围，就把最左指针的贡献去掉。
- 在这个基础上，最终的结果概率，使用的其实就是一个累积概率，一旦i超过或等于K了，就把每个当前位置的概率加总，得到的概率即为`能走到:从K开始直到N，这些位置的概率的和`

`AC`


### 代码
```java
class Solution {
        public double new21Game(int N, int K, int W) {
        if (K == 0 || N >= K + W) return 1;
        double dp[] = new double[N + 1],  Wsum = 1, res = 0;
        dp[0] = 1;
        for (int i = 1; i <= N; ++i) {
            dp[i] = Wsum / W;
            if (i < K) Wsum += dp[i]; else res += dp[i];
            if (i - W >= 0) Wsum -= dp[i - W];
        }
        return res;
    }
}
```


### 复杂度

time: O(N)
space: O(N)
### 思路

- 拿到题的直觉解法
    - 额外空间O(N): 复制一个和nums一样的array，扫一遍copy_nums，超过3次的就跳过，更新nums；
    - 时间复杂度O(NlogN)：扫一遍nums，把重复第三次以上的标记为100001，然后排序一遍；
- 看答案最优解
    - 无需额外空间时间，扫一遍，边扫边更新；
    - 原理：
        - 我们只需要留下符合条件的元素，剩下的不用管，可以覆盖；
        - 那就双指针，一个负责扫，一个负责写
        - 由扫的负责记录重复次数
        - 扫的和写的一起出发
        - 如果扫到第三个重复的，写的那个在第三次重复的地方停下来，扫的继续往前
        - 扫的那个遇到了新的元素，写的那个就在当前位置写新的值
        - 扫的那个继续记录，如果又遇到了第三次重复，则写的停下等待，扫的继续
    - 扫的那个，关键是要负责记录重复次数，这是写不写的条件；
    - 写的那个，只管扫到的什么写什么，与当前所在位置没关系；

`AC`


### 代码
```java
class Solution {
    
    public int removeDuplicates(int[] nums) {
        int pw = 1, count = 1;
        
        for(int i = 1;i < nums.length;i++){
            if(nums[i] == nums[i-1]){
                count++;
            } else {
                count = 1;
            }

            if(count <= 2){
                nums[pw] = nums[i];
                pw++;
            }
        }
        return pw;
    }
}
```


### 复杂度

time: O(N)
space: O(1)